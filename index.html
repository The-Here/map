<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>The Here — Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />

  <style>
    * { box-sizing: border-box; }
    body { margin: 0; padding: 0; }
    #map { position: absolute; inset: 0; }

    /* Timeline UI (fixed bottom bar) */
    #timeline {
      position: fixed;
      left: 12px; right: 12px; bottom: 12px;
      height: 44px;
      background: rgba(255,255,255,0.96);
      border-radius: 14px;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 10px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.14);
      z-index: 1000;
      backdrop-filter: blur(6px);
    }

    #timeline .controls {
      display: flex;
      align-items: center;
      gap: 6px;
      flex: 0 0 auto;
    }

    #timeline button {
      height: 28px;
      min-width: 28px;
      padding: 0 8px;
      border: 0;
      border-radius: 10px;
      background: #eef2f7;
      cursor: pointer;
      font: 600 12px/1 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: #111827;
    }
    #timeline button:hover { filter: brightness(0.98); }
    #timeline button:active { transform: translateY(1px); }

    #yearInput {
      height: 28px;
      width: 96px;
      border: 1px solid #d1d5db;
      border-radius: 10px;
      padding: 0 10px;
      font: 700 12px/1 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: #111827;
      outline: none;
    }

    #sliderWrap {
      position: relative;
      flex: 1 1 auto;
      height: 28px;
      display: flex;
      align-items: center;
      padding: 0 6px;
    }

    #slider {
      width: 100%;
      height: 4px;
      -webkit-appearance: none;
      appearance: none;
      background: #e5e7eb;
      border-radius: 999px;
      outline: none;
      margin: 0;
    }

    #slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px; height: 18px;
      background: #37879d;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    }
    #slider::-moz-range-thumb {
      width: 18px; height: 18px;
      background: #37879d;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.25);
      border: none;
    }

    /* Floating year pill above thumb */
    #year-label {
      position: fixed; /* positioned via JS using viewport coords */
      bottom: 62px;
      font: 800 13px/1 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: #37879d;
      color: #fff;
      padding: 6px 10px;
      border-radius: 999px;
      white-space: nowrap;
      box-shadow: 0 8px 22px rgba(0,0,0,0.22);
      pointer-events: none;
      z-index: 1001;
    }
  </style>
</head>

<body>
  <div id="map"></div>

  <script>
    mapboxgl.accessToken = 'pk.eyJ1Ijoibm9ydGhlZGRhIiwiYSI6ImNtYmVjczJ4cTFndnEycW42cnFwbjBjbzcifQ.XYvDSeoj0uD6K8WpK5v0mQ';

    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/light-v11',
      projection: 'mercator',
      center: [0, 20],
      zoom: 1,
      minZoom: 1,
      maxZoom: 12
    });

    // ==================== TIMELINE (NEW SCALE + JUMP) ====================
    const YEAR_MIN = -3100;
    const YEAR_MAX = 2000;
    const SLIDER_MAX = 10000;

    const TIME_SEGMENTS = [
      { s0:    0, s1: 1800, y0: -3100, y1:    0 },   // ancient compressed
      { s0: 1800, s1: 5200, y0:     0, y1: 1500 },   // medieval/early compressed
      { s0: 5200, s1: 7400, y0:  1500, y1: 1800 },   // early modern
      { s0: 7400, s1: 8600, y0:  1800, y1: 1900 },   // 19th century
      { s0: 8600, s1: 9400, y0:  1900, y1: 1950 },   // early 20th
      { s0: 9400, s1: 9700, y0:  1950, y1: 1975 },   // mid 20th
      { s0: 9700, s1:10000, y0:  1975, y1: 2000 }    // late 20th
    ];

    const SHORT_MONTHS = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

    function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

    function sliderToYear(sv) {
      const v = clamp(Number(sv), 0, SLIDER_MAX);
      for (const seg of TIME_SEGMENTS) {
        if (v >= seg.s0 && v <= seg.s1) {
          const t = (v - seg.s0) / (seg.s1 - seg.s0 || 1);
          return Math.round(seg.y0 + t * (seg.y1 - seg.y0));
        }
      }
      return YEAR_MAX;
    }

    function yearToSlider(y) {
      const yr = clamp(Math.round(Number(y)), YEAR_MIN, YEAR_MAX);
      for (const seg of TIME_SEGMENTS) {
        if (yr >= seg.y0 && yr <= seg.y1) {
          const t = (yr - seg.y0) / (seg.y1 - seg.y0 || 1);
          return Math.round(seg.s0 + t * (seg.s1 - seg.s0));
        }
      }
      return SLIDER_MAX;
    }

    function yearLabelText(y) {
      return (y < 0) ? `${Math.abs(y)} BCE` : `${y}`;
    }

    function positionYearPill(labelEl, sliderEl, sliderValue) {
      const rect = sliderEl.getBoundingClientRect();
      const t = clamp(Number(sliderValue) / SLIDER_MAX, 0, 1);
      let x = rect.left + t * rect.width;

      const pillW = labelEl.offsetWidth || 80;
      const pad = 12;
      const minX = rect.left + pad;
      const maxX = rect.right - pillW - pad;
      x = Math.min(Math.max(x, minX), maxX);

      labelEl.style.left = `${x}px`;
    }

    // ==================== DATA LOADING ====================
    // ONE MAP SOURCE = shared clustering for actions + claims
    const POINTS_SOURCE_ID = 'points';

    // Claims file can be added later; if missing, map still works.
    // Put your user claims here when ready:
    // data/claims/claims.geojson
    const CLAIMS_URL = 'data/claims/claims.geojson';

    function pad4(n) { return String(n).padStart(4, '0'); }

    // Your existing action bundling logic (unchanged)
    function bundlePathForYear(year) {
      if (year < 0) {
        const BCE_START = 3100;
        const abs = Math.abs(year);
        const offset = BCE_START - abs;
        const bucketIndex = Math.floor(Math.max(0, offset) / 500);
        const start = BCE_START - bucketIndex * 500;
        const end = Math.max(1, start - 499);
        return `data/eras/bce_${start}_${end}.geojson`;
      }

      if (year >= 0 && year <= 999) {
        const start = year - (year % 500);
        const end = start + 499;
        return `data/eras/${pad4(start)}_${pad4(end)}.geojson`;
      }

      if (year >= 1000 && year <= 1499) {
        const century = year - (year % 100);
        return `data/centuries/${century}s.geojson`;
      }

      if (year >= 1500 && year <= 2000) {
        const decade = year - (year % 10);
        return `data/decades/${decade}s.geojson`;
      }

      return `data/decades/2000s.geojson`;
    }

    // ==================== helpers: parsing + safety ====================
    function parseMaybeJsonObject(v) {
      if (v == null) return null;
      if (typeof v === 'object') return v;
      if (typeof v !== 'string') return null;
      const s = v.trim();
      if (!s.startsWith('{') || !s.endsWith('}')) return null;
      try {
        const obj = JSON.parse(s);
        return (obj && typeof obj === 'object') ? obj : null;
      } catch {
        return null;
      }
    }

    function parseMaybeJsonArray(v) {
      if (v == null) return null;
      if (Array.isArray(v)) return v;
      if (typeof v !== 'string') return null;
      const s = v.trim();
      if (!s.startsWith('[') || !s.endsWith(']')) return null;
      try {
        const arr = JSON.parse(s);
        return Array.isArray(arr) ? arr : null;
      } catch {
        return null;
      }
    }

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, (m) => ({
        '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
      }[m]));
    }

    function tryDomain(url) {
      try { return new URL(url).hostname; } catch { return ''; }
    }

    function extractOldid(url) {
      if (!url) return null;
      let m = String(url).match(/oldid=(\d+)/);
      if (m) return m[1];
      m = String(url).match(/Special:Permalink\/(\d+)/);
      return m ? m[1] : null;
    }

    function getTagsArray(p) {
      if (!p) return [];
      if (Array.isArray(p.tags)) return p.tags.filter(Boolean);
      if (typeof p.tags === 'string') {
        const arr = parseMaybeJsonArray(p.tags);
        if (arr) return arr.filter(Boolean);
        // fallback: comma-separated
        return p.tags.split(',').map(x => x.trim()).filter(Boolean);
      }
      return [];
    }

    function getTimeValue(p) {
      if (!p) return null;

      // Preferred: flat "date"
      if (p.date != null) return p.date;

      // Preferred: nested "time.value"
      if (p.time && typeof p.time === 'object' && p.time.value != null) return p.time.value;

      // Mapbox may serialize objects; accept string time if it looks like JSON or date-like
      if (typeof p.time === 'string') {
        const obj = parseMaybeJsonObject(p.time);
        if (obj && obj.value != null) return obj.value;
        return p.time;
      }

      if (p.time_value != null) return p.time_value;
      if (p.timeValue != null) return p.timeValue;

      return null;
    }

    function getTimePrecision(p) {
      if (!p) return null;

      if (p.time_precision != null) return String(p.time_precision);
      if (p.time && typeof p.time === 'object' && p.time.precision != null) return String(p.time.precision);

      if (typeof p.time === 'string') {
        const obj = parseMaybeJsonObject(p.time);
        if (obj && obj.precision != null) return String(obj.precision);
      }

      return null;
    }

    function extractYearFromTimeValue(v) {
      if (v == null) return null;
      const s = String(v).trim();

      // ISO-ish: YYYY, YYYY-MM, YYYY-MM-DD, including negative
      let m = s.match(/^(-?\d{1,6})(?:-(\d{2})(?:-(\d{2}))?)?$/);
      if (m) {
        const y = parseInt(m[1], 10);
        return Number.isFinite(y) ? y : null;
      }

      // "YYYY, Aug 3" or "YYYY Aug 3" (comma optional)
      m = s.match(/^(-?\d+)\s*,?\s*([A-Za-z]{3})\s+(\d{1,2})$/);
      if (m) {
        const y = parseInt(m[1], 10);
        return Number.isFinite(y) ? y : null;
      }

      // "3100 BCE, Aug 3" or "3100 BCE Aug 3"
      m = s.match(/^(\d+)\s*BCE\s*,?\s*([A-Za-z]{3})\s+(\d{1,2})$/i);
      if (m) {
        const y = -parseInt(m[1], 10);
        return Number.isFinite(y) ? y : null;
      }

      // "3100 BCE"
      m = s.match(/^(\d+)\s*BCE$/i);
      if (m) {
        const y = -parseInt(m[1], 10);
        return Number.isFinite(y) ? y : null;
      }

      return null;
    }

    function featureYear(f) {
      const p = (f && f.properties) ? f.properties : {};
      const tv = getTimeValue(p);
      const y1 = extractYearFromTimeValue(tv);
      if (y1 != null) return y1;

      if (p.year != null) {
        const y2 = parseInt(p.year, 10);
        if (Number.isFinite(y2)) return y2;
      }

      return null;
    }

    // ==================== normalize: actions + claims ====================
    function normalizeFeatureKindAndId(feature, defaultKind) {
      const copy = Object.assign({}, feature);
      copy.properties = Object.assign({}, feature.properties || {});
      const p = copy.properties;

      // kind
      p.kind = (p.kind || defaultKind || 'action');

      // label/title
      p.label = p.action || p.title || p.label || (p.kind === 'claim' ? 'Claim' : 'Action');

      // id (Mapbox likes feature.id)
      if (!copy.id) {
        copy.id = p.action_id || p.id || p.claim_id || p.claimId || undefined;
      }

      // computed year cache
      if (p._year == null) p._year = featureYear(copy);

      return copy;
    }

    function normalizeActionsGeojson(gj) {
      const features = Array.isArray(gj && gj.features) ? gj.features : [];
      return {
        type: 'FeatureCollection',
        features: features.map(f => normalizeFeatureKindAndId(f, 'action'))
      };
    }

    function normalizeClaimsGeojson(gj) {
      const features = Array.isArray(gj && gj.features) ? gj.features : [];
      return {
        type: 'FeatureCollection',
        features: features.map(f => normalizeFeatureKindAndId(f, 'claim'))
      };
    }

    // ==================== caching: action bundles ====================
    const bundleCache = new Map(); // path -> { byYear: Map<number, Feature[]>, normalized: FeatureCollection }
    const MAX_BUNDLES = 10;
    let requestSeq = 0;
    let lastLoadedYear = null;

    async function fetchActionBundle(path) {
      if (bundleCache.has(path)) {
        const v = bundleCache.get(path);
        bundleCache.delete(path);
        bundleCache.set(path, v);
        return v;
      }

      const res = await fetch(path, { cache: 'force-cache' });
      if (!res.ok) return null;

      const raw = await res.json();
      const normalized = normalizeActionsGeojson(raw);

      const byYear = new Map();
      for (const f of normalized.features) {
        const y = f && f.properties ? f.properties._year : null;
        if (y == null) continue;
        if (!byYear.has(y)) byYear.set(y, []);
        byYear.get(y).push(f);
      }

      const entry = { normalized, byYear };

      bundleCache.set(path, entry);
      if (bundleCache.size > MAX_BUNDLES) {
        const firstKey = bundleCache.keys().next().value;
        bundleCache.delete(firstKey);
      }

      return entry;
    }

    // ==================== indexing: claims ====================
    const claimsByYear = new Map();    // year -> Feature[]
    const claimsByAction = new Map();  // parent_action_id -> Feature[]
    let claimsLoaded = false;

    function indexClaimFeature(f) {
      const p = f && f.properties ? f.properties : {};
      const y = p._year;
      if (y != null) {
        if (!claimsByYear.has(y)) claimsByYear.set(y, []);
        claimsByYear.get(y).push(f);
      }

      const pid = p.parent_action_id || p.parentActionId || p.action_id || p.actionId;
      if (pid) {
        const key = String(pid);
        if (!claimsByAction.has(key)) claimsByAction.set(key, []);
        claimsByAction.get(key).push(f);
      }
    }

    async function loadClaimsOnce() {
      if (claimsLoaded) return;
      claimsLoaded = true;

      try {
        const res = await fetch(CLAIMS_URL, { cache: 'no-store' });
        if (!res.ok) return;

        const raw = await res.json();
        const normalized = normalizeClaimsGeojson(raw);

        for (const f of normalized.features) indexClaimFeature(f);
      } catch (e) {
        // Missing file is fine (you’ll add it later)
        console.warn('Claims not loaded (ok for now):', e);
      }
    }

    // ==================== setYear: merge actions + claims into ONE source ====================
    async function setYear(targetYear) {
      if (!map.getSource(POINTS_SOURCE_ID)) return;

      const y = clamp(Math.round(Number(targetYear)), YEAR_MIN, YEAR_MAX);
      if (y === lastLoadedYear) return;
      lastLoadedYear = y;

      const seq = ++requestSeq;
      const path = bundlePathForYear(y);

      try {
        const entry = await fetchActionBundle(path);
        const actionFeaturesForYear = entry && entry.byYear ? (entry.byYear.get(y) || []) : [];
        const claimFeaturesForYear = claimsByYear.get(y) || [];

        const fc = {
          type: 'FeatureCollection',
          features: actionFeaturesForYear.concat(claimFeaturesForYear)
        };

        if (seq === requestSeq) {
          map.getSource(POINTS_SOURCE_ID).setData(fc);
        }
      } catch (e) {
        const empty = { type: 'FeatureCollection', features: [] };
        if (seq === requestSeq) map.getSource(POINTS_SOURCE_ID).setData(empty);
        console.warn('Failed to load year data:', path, e);
      }
    }

    // Displays: "1914, Aug 3" / "1914, Aug" / "1914" / "3100 BCE, Aug 3" etc.
    function formatDisplayDate(p) {
      const vRaw = getTimeValue(p);
      if (vRaw == null) return '';

      const precision = (getTimePrecision(p) || '').toLowerCase();
      const s = String(vRaw).trim();

      // Already in "YYYY, Aug 3" (comma optional)
      let m = s.match(/^(-?\d+)\s*,?\s*([A-Za-z]{3})\s+(\d{1,2})$/);
      if (m) {
        const y = parseInt(m[1], 10);
        const mon = (m[2][0].toUpperCase() + m[2].slice(1, 3).toLowerCase());
        const d = parseInt(m[3], 10);
        if (!Number.isFinite(y) || !Number.isFinite(d)) return s;

        if (precision === 'year') return (y < 0) ? `${Math.abs(y)} BCE` : `${y}`;
        if (precision === 'month') return (y < 0) ? `${Math.abs(y)} BCE, ${mon}` : `${y}, ${mon}`;

        return (y < 0) ? `${Math.abs(y)} BCE, ${mon} ${d}` : `${y}, ${mon} ${d}`;
      }

      // ISO: YYYY / YYYY-MM / YYYY-MM-DD (including negative)
      m = s.match(/^(-?\d{1,6})(?:-(\d{2})(?:-(\d{2}))?)?$/);
      if (m) {
        const y = parseInt(m[1], 10);
        const mm = m[2] ? parseInt(m[2], 10) : null;
        const dd = m[3] ? parseInt(m[3], 10) : null;

        if (!Number.isFinite(y)) return s;

        if (precision === 'year' || !mm) return (y < 0) ? `${Math.abs(y)} BCE` : `${y}`;

        const mon = SHORT_MONTHS[mm - 1] || '';
        if (precision === 'month' || !dd) return (y < 0) ? `${Math.abs(y)} BCE, ${mon}` : `${y}, ${mon}`;

        return (y < 0) ? `${Math.abs(y)} BCE, ${mon} ${dd}` : `${y}, ${mon} ${dd}`;
      }

      // "3100 BCE, Aug 3" (comma optional)
      m = s.match(/^(\d+)\s*BCE\s*,?\s*([A-Za-z]{3})\s+(\d{1,2})$/i);
      if (m) {
        const yAbs = parseInt(m[1], 10);
        const mon = (m[2][0].toUpperCase() + m[2].slice(1, 3).toLowerCase());
        const d = parseInt(m[3], 10);
        if (!Number.isFinite(yAbs) || !Number.isFinite(d)) return s;

        if (precision === 'year') return `${yAbs} BCE`;
        if (precision === 'month') return `${yAbs} BCE, ${mon}`;
        return `${yAbs} BCE, ${mon} ${d}`;
      }

      // "3100 BCE"
      m = s.match(/^(\d+)\s*BCE$/i);
      if (m) return `${m[1]} BCE`;

      return s;
    }

    // ==================== UI ====================
    function initTimeline() {
      document.body.insertAdjacentHTML('beforeend', `
        <div id="timeline">
          <div class="controls">
            <button id="yMinus10" title="-10 years">−10</button>
            <button id="yMinus1"  title="-1 year">−</button>
            <input id="yearInput" type="number" min="${YEAR_MIN}" max="${YEAR_MAX}" step="1" value="2000" />
            <button id="yPlus1"   title="+1 year">+</button>
            <button id="yPlus10"  title="+10 years">+10</button>
          </div>

          <div id="sliderWrap">
            <input id="slider" type="range" min="0" max="${SLIDER_MAX}" value="${SLIDER_MAX}" step="1" />
          </div>
        </div>
        <div id="year-label">2000</div>
      `);

      const slider = document.getElementById('slider');
      const yearInput = document.getElementById('yearInput');
      const yearLabel = document.getElementById('year-label');

      let raf = null;

      function applyYear(y) {
        const yr = clamp(Math.round(Number(y)), YEAR_MIN, YEAR_MAX);
        const sv = yearToSlider(yr);

        slider.value = String(sv);
        yearInput.value = String(yr);

        yearLabel.textContent = yearLabelText(yr);
        positionYearPill(yearLabel, slider, sv);

        cancelAnimationFrame(raf);
        raf = requestAnimationFrame(() => setYear(yr));
      }

      function adjust(delta) {
        const current = clamp(parseInt(yearInput.value || '0', 10), YEAR_MIN, YEAR_MAX);
        applyYear(current + delta);
      }

      // Slider drag
      slider.addEventListener('input', (e) => {
        const sv = Number(e.target.value);
        const yr = sliderToYear(sv);
        yearInput.value = String(yr);
        yearLabel.textContent = yearLabelText(yr);
        positionYearPill(yearLabel, slider, sv);

        cancelAnimationFrame(raf);
        raf = requestAnimationFrame(() => setYear(yr));
      });

      // Jump-to-year input (Enter or blur)
      yearInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          applyYear(parseInt(yearInput.value, 10));
          yearInput.blur();
        }
      });
      yearInput.addEventListener('change', () => applyYear(parseInt(yearInput.value, 10)));

      // Buttons
      document.getElementById('yMinus10').addEventListener('click', () => adjust(-10));
      document.getElementById('yMinus1').addEventListener('click', () => adjust(-1));
      document.getElementById('yPlus1').addEventListener('click', () => adjust(1));
      document.getElementById('yPlus10').addEventListener('click', () => adjust(10));

      // Keyboard anywhere (ignore when typing in input)
      window.addEventListener('keydown', (e) => {
        if (document.activeElement === yearInput) return;

        const isLeft = (e.key === 'ArrowLeft');
        const isRight = (e.key === 'ArrowRight');
        if (!isLeft && !isRight) return;

        e.preventDefault();

        const current = clamp(parseInt(yearInput.value || '0', 10), YEAR_MIN, YEAR_MAX);
        let step = 1;

        if (e.altKey) step = 100;
        else if (e.shiftKey) step = 10;
        else {
          if (current < 0) step = 25;
          else if (current < 1500) step = 10;
          else if (current < 1800) step = 5;
          else step = 1;
        }

        applyYear(current + (isRight ? step : -step));
      });

      // Shift+wheel = fine scrub
      window.addEventListener('wheel', (e) => {
        if (!e.shiftKey) return;
        e.preventDefault();

        const current = clamp(parseInt(yearInput.value || '0', 10), YEAR_MIN, YEAR_MAX);
        let step = 1;

        if (current < 0) step = 25;
        else if (current < 1500) step = 10;
        else if (current < 1800) step = 5;
        else step = 1;

        applyYear(current + (e.deltaY > 0 ? -step : step));
      }, { passive: false });

      window.addEventListener('resize', () => {
        const sv = Number(slider.value);
        positionYearPill(yearLabel, slider, sv);
      });

      applyYear(2000);
    }

    // ==================== POPUPS ====================
    function buildSourceLinkHtml(url) {
      if (!url) return '';
      const domain = tryDomain(url);
      const oldid = extractOldid(url);
      let label = domain || 'Reference';
      if (domain && domain.includes('wikipedia.org') && oldid) label = `Wikipedia (oldid ${oldid})`;
      return `<a href="${url}" target="_blank" rel="noopener" style="color:#1e40af;">${escapeHtml(label)}</a>`;
    }

    function popupForAction(feature, lngLat) {
      const p = feature.properties || {};
      const actionId = String(feature.id || p.id || p.action_id || '');

      const title = p.action || p.title || p.label || 'Action';
      const dateStr = formatDisplayDate(p);

      const location = p.place_name || p.location || p.place || p.location_name || p.site || p.city || '';
      const country = p.place_country || p.country || '';
      const countriesList = (p.countries && typeof p.countries === 'string')
        ? p.countries
        : (Array.isArray(p.countries) ? p.countries.join(', ') : country);

      const refUrl = p.ref_url || p.wiki || p.wikipedia || p.url || '';
      const refLink = buildSourceLinkHtml(refUrl);

      const attached = claimsByAction.get(actionId) || [];
      const n = attached.length;

      const list = attached
        .slice(0, 10)
        .map(c => {
          const cp = c.properties || {};
          const t = cp.title || cp.label || cp.claim_id || 'Claim';
          const tags = getTagsArray(cp).slice(0, 6);
          const tagsLine = tags.length ? `<div style="opacity:.75; font-size:12px;">${escapeHtml(tags.join(', '))}</div>` : '';
          const link = (cp.claim_url || cp.ref_url || cp.url) ? `<a href="${cp.claim_url || cp.ref_url || cp.url}" target="_blank" rel="noopener" style="color:#1e40af; font-size:12px;">Open</a>` : '';
          return `
            <div style="margin:8px 0; padding-top:8px; border-top:1px solid rgba(0,0,0,0.08);">
              <div style="display:flex; justify-content:space-between; gap:10px;">
                <div style="font-weight:700;">${escapeHtml(t)}</div>
                ${link}
              </div>
              ${tagsLine}
            </div>
          `;
        })
        .join('');

      const more = n > 10 ? `<div style="margin-top:8px; opacity:.75;">+ ${n - 10} more</div>` : '';

      const html = `
        <div style="max-width: 340px; padding: 8px; font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;">
          <div style="font-weight:800; font-size:14px;">${escapeHtml(title)}</div>
          ${dateStr ? `<div style="margin-top:4px;">${escapeHtml(dateStr)}</div>` : ''}
          ${location ? `<div style="margin-top:4px;">${escapeHtml(location)}</div>` : ''}
          ${countriesList ? `<div style="margin-top:2px; opacity:.8;">${escapeHtml(countriesList)}</div>` : ''}
          ${refLink ? `<div style="margin-top:8px;"><b>Source:</b> ${refLink}</div>` : ''}

          <div style="margin-top:10px; font-weight:800;">Claims attached (${n})</div>
          ${n ? `<div>${list}${more}</div>` : `<div style="opacity:.75; margin-top:6px;">No claims yet.</div>`}
        </div>
      `;

      new mapboxgl.Popup({ offset: 15 }).setLngLat(lngLat).setHTML(html).addTo(map);
    }

    function popupForClaim(feature, lngLat) {
      const p = feature.properties || {};
      const title = p.title || p.label || 'Claim';
      const dateStr = formatDisplayDate(p);

      const tags = getTagsArray(p).slice(0, 10);
      const tagsLine = tags.length ? `<div style="margin-top:6px; opacity:.8;">${escapeHtml(tags.join(', '))}</div>` : '';

      const linkHref = p.claim_url || p.ref_url || p.url || '';
      const link = linkHref ? `<a href="${linkHref}" target="_blank" rel="noopener" style="color:#1e40af;">Open story</a>` : '';

      const parentId = p.parent_action_id || p.parentActionId || '';
      const parentLine = parentId ? `<div style="margin-top:8px; opacity:.85;"><b>Anchored to:</b> ${escapeHtml(parentId)}</div>` : '';

      const html = `
        <div style="max-width: 320px; padding: 8px; font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;">
          <div style="font-weight:800; font-size:14px;">${escapeHtml(title)}</div>
          ${dateStr ? `<div style="margin-top:4px;">${escapeHtml(dateStr)}</div>` : ''}
          ${tagsLine}
          ${parentLine}
          ${link ? `<div style="margin-top:10px;">${link}</div>` : ''}
        </div>
      `;

      new mapboxgl.Popup({ offset: 15 }).setLngLat(lngLat).setHTML(html).addTo(map);
    }

    // ==================== MAP ====================
    map.on('load', async () => {
      // Load claims (if file exists). Safe if missing.
      await loadClaimsOnce();

      // One source for BOTH actions + claims => shared clusters
      map.addSource(POINTS_SOURCE_ID, {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] },
        cluster: true,
        clusterRadius: 50,
        // count types inside clusters
        clusterProperties: {
          action_count: ["+", ["case", ["==", ["get", "kind"], "action"], 1, 0]],
          claim_count:  ["+", ["case", ["==", ["get", "kind"], "claim"], 1, 0]]
        }
      });

      map.addLayer({
        id: 'points-clusters',
        type: 'circle',
        source: POINTS_SOURCE_ID,
        filter: ['has', 'point_count'],
        paint: {
          'circle-color': ['step', ['get', 'point_count'], '#51bbd6', 10, '#f1f075', 30, '#f28cb1'],
          'circle-radius': ['step', ['get', 'point_count'], 15, 10, 20, 30, 25],
          'circle-opacity': 0.9,
          'circle-stroke-color': '#fff',
          'circle-stroke-width': 1
        }
      });

      // Cluster label: total + (A x / C y)
      map.addLayer({
        id: 'points-cluster-count',
        type: 'symbol',
        source: POINTS_SOURCE_ID,
        filter: ['has', 'point_count'],
        layout: {
          'text-field': [
            'format',
            ['get', 'point_count_abbreviated'], { 'font-scale': 1.0 },
            '\n', {},
            'A:', { 'font-scale': 0.85 },
            ['to-string', ['get', 'action_count']], { 'font-scale': 0.85 },
            '  C:', { 'font-scale': 0.85 },
            ['to-string', ['get', 'claim_count']], { 'font-scale': 0.85 }
          ],
          'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
          'text-size': 12,
          'text-justify': 'center'
        },
        paint: { 'text-color': '#000000' }
      });

      // Unclustered points (same source). Color by kind.
      map.addLayer({
        id: 'points-unclustered',
        type: 'circle',
        source: POINTS_SOURCE_ID,
        filter: ['!', ['has', 'point_count']],
        paint: {
          'circle-radius': ['case', ['==', ['get', 'kind'], 'claim'], 7, 8],
          'circle-color': ['match', ['get', 'kind'], 'claim', '#111827', 'action', '#37879d', '#37879d'],
          'circle-opacity': 0.9,
          'circle-stroke-color': '#ffffff',
          'circle-stroke-width': 1
        }
      });

      // Cluster click -> zoom in
      map.on('click', 'points-clusters', (e) => {
        const f = map.queryRenderedFeatures(e.point, { layers: ['points-clusters'] })[0];
        if (!f) return;
        const clusterId = f.properties.cluster_id;
        map.getSource(POINTS_SOURCE_ID).getClusterExpansionZoom(clusterId, (err, zoom) => {
          if (err) return;
          map.easeTo({ center: f.geometry.coordinates, zoom });
        });
      });

      // Point click -> action popup or claim popup
      map.on('click', 'points-unclustered', (e) => {
        const f = map.queryRenderedFeatures(e.point, { layers: ['points-unclustered'] })[0];
        if (!f) return;

        const p = f.properties || {};
        const kind = p.kind || 'action';

        if (kind === 'claim') popupForClaim(f, e.lngLat);
        else popupForAction(f, e.lngLat);
      });

      initTimeline();
    });
  </script>
</body>
</html>
