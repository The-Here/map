<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>The Here — Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; padding: 0; }
    #map { position: absolute; inset: 0; }
  </style>
</head>
<body>
<div id="map"></div>

<script>
  mapboxgl.accessToken = 'pk.eyJ1Ijoibm9ydGhlZGRhIiwiYSI6ImNtYmVjczJ4cTFndnEycW42cnFwbjBjbzcifQ.XYvDSeoj0uD6K8WpK5v0mQ';

  const map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/light-v11',
    projection: 'mercator',
    center: [0, 20],
    zoom: 1,
    minZoom: 1,
    maxZoom: 12
  });

  // ==================== TIMELINE ====================
  const TIME_SEGMENTS = [
    { sliderStart: 0,   sliderEnd: 100,   yearStart: -3100, yearEnd: 0 },
    { sliderStart: 100, sliderEnd: 200,   yearStart: 0,     yearEnd: 1600 },
    { sliderStart: 200, sliderEnd: 300,   yearStart: 1600,  yearEnd: 1700 },
    { sliderStart: 300, sliderEnd: 400,   yearStart: 1700,  yearEnd: 1800 },
    { sliderStart: 400, sliderEnd: 500,   yearStart: 1800,  yearEnd: 1850 },
    { sliderStart: 500, sliderEnd: 600,   yearStart: 1850,  yearEnd: 1900 },
    { sliderStart: 600, sliderEnd: 700,   yearStart: 1900,  yearEnd: 1950 },
    { sliderStart: 700, sliderEnd: 800,   yearStart: 1950,  yearEnd: 1975 },
    { sliderStart: 800, sliderEnd: 900,   yearStart: 1975,  yearEnd: 2000 },
    { sliderStart: 900, sliderEnd: 1000,  yearStart: 2000,  yearEnd: 2000 }
  ];

  function sliderToYear(sliderValue) {
    for (const segment of TIME_SEGMENTS) {
      if (sliderValue >= segment.sliderStart && sliderValue <= segment.sliderEnd) {
        const segmentProgress = (sliderValue - segment.sliderStart) / (segment.sliderEnd - segment.sliderStart);
        return Math.round(segment.yearStart + segmentProgress * (segment.yearEnd - segment.yearStart));
      }
    }
    return 2000;
  }

  function updateYearLabel(targetYear, sliderValue) {
    const label = document.getElementById('year-label');
    const slider = document.getElementById('slider');
    if (!label || !slider) return;

    label.textContent = targetYear >= 0 ? `${targetYear}` : `${Math.abs(targetYear)} BCE`;

    const sliderRect = slider.getBoundingClientRect();
    const percent = sliderValue / 1000;
    let thumbX = sliderRect.left + percent * sliderRect.width;

    const padding = 10;
    const labelWidth = label.offsetWidth || 60;
    const minX = sliderRect.left + padding;
    const maxX = sliderRect.right - labelWidth - padding;

    thumbX = Math.min(Math.max(thumbX, minX), maxX);
    label.style.left = `${thumbX}px`;
  }

  // ==================== TIMELINE CSS ====================
  const timelineStyle = document.createElement('style');
  timelineStyle.textContent = `
    #timeline {
      position: absolute; bottom: 10px; left: 0; right: 0;
      height: 25px; background: rgba(255,255,255,0.95);
      display: flex; align-items: center; justify-content: center;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.1); z-index: 1000;
    }
    #slider {
      width: 90%; height: 4px; margin: 0 20px;
      -webkit-appearance: none; appearance: none;
      background: #ddd; border-radius: 2px; outline: none;
    }
    #slider::-webkit-slider-thumb {
      -webkit-appearance: none; appearance: none;
      width: 18px; height: 18px; background: #37879d;
      border-radius: 50%; cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    #slider::-moz-range-thumb {
      width: 18px; height: 18px; background: #37879d;
      border-radius: 50%; cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      border: none;
    }
    #year-label {
      position: absolute; bottom: 28px;
      font-size: 13px; font-weight: 600;
      background: #37879d; color: white; padding: 4px 10px;
      border-radius: 15px; white-space: nowrap;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      transition: all 0.1s ease; pointer-events: none;
    }
  `;
  document.head.appendChild(timelineStyle);

  // ==================== DATA LOADING (BUNDLES) ====================
  // Expected generated files:
  //   data/decades/1910s.geojson          (1500–2000)
  //   data/centuries/1200s.geojson        (1000–1499)
  //   data/eras/0000_0499.geojson         (0–999)
  //   data/eras/bce_3100_2601.geojson     (-3100..-1, 500y blocks anchored at 3100)
  const ACTIONS_SOURCE_ID = 'actions';

  function pad4(n) { return String(n).padStart(4, '0'); }

  function bundlePathForYear(year) {
    // BCE: -3100..-1 => 500-year blocks anchored at 3100 BCE:
    // bce_3100_2601, bce_2600_2101, ... , bce_100_1
    if (year < 0) {
      const BCE_START = 3100;
      const abs = Math.abs(year);
      const offset = BCE_START - abs;
      const bucketIndex = Math.floor(Math.max(0, offset) / 500);
      const start = BCE_START - bucketIndex * 500;
      const end = Math.max(1, start - 499);
      return `data/eras/bce_${start}_${end}.geojson`;
    }

    // CE 0..999 => 0000_0499, 0500_0999
    if (year >= 0 && year <= 999) {
      const start = year - (year % 500);
      const end = start + 499;
      return `data/eras/${pad4(start)}_${pad4(end)}.geojson`;
    }

    // 1000..1499 => centuries
    if (year >= 1000 && year <= 1499) {
      const century = year - (year % 100);
      return `data/centuries/${century}s.geojson`;
    }

    // 1500..2000 => decades
    if (year >= 1500 && year <= 2000) {
      const decade = year - (year % 10);
      return `data/decades/${decade}s.geojson`;
    }

    // you said timeline closed at 2000
    return `data/decades/2000s.geojson`;
  }

  function extractYearFromTimeValue(v) {
    if (v == null) return null;
    const s = String(v).trim();

    // ISO: 1914-08-10 or -3100-01-01 or 1914-08 or 1914
    let m = s.match(/^(-?\d{1,6})(?:-(\d{2})(?:-(\d{2}))?)?$/);
    if (m) {
      const y = parseInt(m[1], 10);
      return Number.isFinite(y) ? y : null;
    }

    // "1914, Aug 3" or "-3100, Aug 3"
    m = s.match(/^(-?\d+)\s*,\s*([A-Za-z]{3})\s+(\d{1,2})$/);
    if (m) {
      const y = parseInt(m[1], 10);
      return Number.isFinite(y) ? y : null;
    }

    // "3100 BCE, Aug 3" -> -3100
    m = s.match(/^(\d+)\s*BCE\s*,\s*([A-Za-z]{3})\s+(\d{1,2})$/i);
    if (m) {
      const y = -parseInt(m[1], 10);
      return Number.isFinite(y) ? y : null;
    }

    return null;
  }

  function featureYear(f) {
    const p = (f && f.properties) ? f.properties : {};

    // preferred: properties.time.value
    if (p.time && typeof p.time === 'object' && p.time.value != null) {
      const y = extractYearFromTimeValue(p.time.value);
      if (y != null) return y;
    }

    // legacy: properties.date
    if (p.date != null) {
      const y = extractYearFromTimeValue(p.date);
      if (y != null) return y;
    }

    // fallback: properties.year
    if (p.year != null) {
      const y = parseInt(p.year, 10);
      if (Number.isFinite(y)) return y;
    }

    return null;
  }

  function normalizeGeojsonForUI(gj) {
    const features = Array.isArray(gj && gj.features) ? gj.features : [];
    return {
      type: 'FeatureCollection',
      features: features.map(f => {
        const copy = Object.assign({}, f);
        copy.properties = Object.assign({}, f.properties || {});
        const p = copy.properties;

        // stable label
        p.label = p.action || p.title || 'Action';

        // stable id
        if (!copy.id) copy.id = p.action_id || undefined;

        // precompute year for fast filtering
        if (p._year == null) p._year = featureYear(copy);

        return copy;
      })
    };
  }

  // Cache bundles (LRU-ish)
  const bundleCache = new Map(); // path -> { byYear: Map<number, Feature[]>, normalized: FeatureCollection }
  const MAX_BUNDLES = 10;
  let requestSeq = 0;
  let lastLoadedYear = null;
  let lastLoadedBundlePath = null;

  async function fetchBundle(path) {
    // touch LRU
    if (bundleCache.has(path)) {
      const v = bundleCache.get(path);
      bundleCache.delete(path);
      bundleCache.set(path, v);
      return v;
    }

    const res = await fetch(path, { cache: 'force-cache' });
    if (!res.ok) return null;

    const raw = await res.json();
    const normalized = normalizeGeojsonForUI(raw);

    const byYear = new Map();
    for (const f of normalized.features) {
      const y = f && f.properties ? f.properties._year : null;
      if (y == null) continue;
      if (!byYear.has(y)) byYear.set(y, []);
      byYear.get(y).push(f);
    }

    const entry = { normalized, byYear };

    bundleCache.set(path, entry);
    if (bundleCache.size > MAX_BUNDLES) {
      const firstKey = bundleCache.keys().next().value;
      bundleCache.delete(firstKey);
    }

    return entry;
  }

  async function setYear(targetYear) {
    if (!map.getSource(ACTIONS_SOURCE_ID)) return;

    if (targetYear === lastLoadedYear) return;
    lastLoadedYear = targetYear;

    const seq = ++requestSeq;
    const path = bundlePathForYear(targetYear);
    lastLoadedBundlePath = path;

    try {
      const entry = await fetchBundle(path);

      // missing bundle file => show empty (no noise)
      const featuresForYear = entry && entry.byYear ? (entry.byYear.get(targetYear) || []) : [];
      const fc = { type: 'FeatureCollection', features: featuresForYear };

      // last-response-wins guard
      if (seq === requestSeq) {
        map.getSource(ACTIONS_SOURCE_ID).setData(fc);
      }
    } catch (e) {
      const empty = { type: 'FeatureCollection', features: [] };
      if (seq === requestSeq) map.getSource(ACTIONS_SOURCE_ID).setData(empty);
      console.warn('Failed to load bundle:', path, e);
    }
  }

  function formatDisplayDate(p) {
    // prefer time.value
    let v = null;
    if (p.time && typeof p.time === 'object' && p.time.value != null) v = p.time.value;
    else if (p.date != null) v = p.date;

    if (v == null) return '';

    const s = String(v).trim();

    // If already "YYYY, Mon D" or "-YYYY, Mon D"
    let m = s.match(/^(-?\d+)\s*,\s*([A-Za-z]{3})\s+(\d{1,2})$/);
    if (m) {
      const y = parseInt(m[1], 10);
      const mon = (m[2][0].toUpperCase() + m[2].slice(1, 3).toLowerCase());
      const d = parseInt(m[3], 10);
      if (!Number.isFinite(y) || !Number.isFinite(d)) return s;
      return (y < 0) ? `${Math.abs(y)} BCE, ${mon} ${d}` : `${y}, ${mon} ${d}`;
    }

    // ISO: YYYY-MM-DD or -YYYY-MM-DD or YYYY-MM or YYYY
    m = s.match(/^(-?\d{1,6})(?:-(\d{2})(?:-(\d{2}))?)?$/);
    if (m) {
      const y = parseInt(m[1], 10);
      const mm = m[2] ? parseInt(m[2], 10) : null;
      const dd = m[3] ? parseInt(m[3], 10) : null;

      const shortMonths = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      if (!Number.isFinite(y)) return s;

      // year only
      if (!mm) return (y < 0) ? `${Math.abs(y)} BCE` : `${y}`;

      // year+month
      const mon = shortMonths[mm - 1] || '';
      if (!dd) return (y < 0) ? `${Math.abs(y)} BCE, ${mon}` : `${y}, ${mon}`;

      // full date
      return (y < 0) ? `${Math.abs(y)} BCE, ${mon} ${dd}` : `${y}, ${mon} ${dd}`;
    }

    return s;
  }

  // ==================== UI ====================
  function initTimeline() {
    document.body.insertAdjacentHTML('beforeend', `
      <div id="timeline">
        <input id="slider" type="range" min="0" max="1000" value="900" step="1">
        <div id="year-label">2000</div>
      </div>
    `);

    const slider = document.getElementById('slider');

    let raf = null;
    slider.addEventListener('input', (e) => {
      const sliderValue = parseFloat(e.target.value);
      const targetYear = sliderToYear(sliderValue);
      updateYearLabel(targetYear, sliderValue);

      cancelAnimationFrame(raf);
      raf = requestAnimationFrame(() => setYear(targetYear));
    });

    const initialSliderValue = 850;
    const initialYear = sliderToYear(initialSliderValue);
    updateYearLabel(initialYear, initialSliderValue);
    setYear(initialYear);
  }

  // ==================== MAP ====================
  map.on('load', () => {
    map.addSource(ACTIONS_SOURCE_ID, {
      type: 'geojson',
      data: { type: 'FeatureCollection', features: [] },
      cluster: true,
    });

    map.addLayer({
      id: 'actions-clusters',
      type: 'circle',
      source: ACTIONS_SOURCE_ID,
      filter: ['has', 'point_count'],
      paint: {
        'circle-color': ['step', ['get', 'point_count'], '#51bbd6', 10, '#f1f075', 30, '#f28cb1'],
        'circle-radius': ['step', ['get', 'point_count'], 15, 10, 20, 30, 25],
        'circle-opacity': 0.9,
        'circle-stroke-color': '#fff',
        'circle-stroke-width': 1
      }
    });

    map.addLayer({
      id: 'actions-cluster-count',
      type: 'symbol',
      source: ACTIONS_SOURCE_ID,
      filter: ['has', 'point_count'],
      layout: {
        'text-field': ['get', 'point_count_abbreviated'],
        'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
        'text-size': 12
      },
      paint: { 'text-color': '#000000' }
    });

    map.addLayer({
      id: 'actions-unclustered',
      type: 'circle',
      source: ACTIONS_SOURCE_ID,
      filter: ['!', ['has', 'point_count']],
      paint: {
        'circle-radius': 8,
        'circle-color': '#37879d',
        'circle-opacity': 0.9,
        'circle-stroke-color': '#ffffff',
        'circle-stroke-width': 1
      }
    });

    // click cluster -> expand
    map.on('click', 'actions-clusters', (e) => {
      const f = map.queryRenderedFeatures(e.point, { layers: ['actions-clusters'] })[0];
      if (!f) return;
      const clusterId = f.properties.cluster_id;
      map.getSource(ACTIONS_SOURCE_ID).getClusterExpansionZoom(clusterId, (err, zoom) => {
        if (err) return;
        map.easeTo({ center: f.geometry.coordinates, zoom });
      });
    });

    // click point -> popup
    map.on('click', 'actions-unclustered', (e) => {
      const f = map.queryRenderedFeatures(e.point, { layers: ['actions-unclustered'] })[0];
      if (!f) return;
      const p = f.properties || {};

      const title = p.action || p.label || 'Action';
      const dateStr = formatDisplayDate(p);

      const location = p.place_name || p.location || p.place || p.location_name || p.site || p.city || '';
      const country = p.place_country || p.country || '';
      const countriesList = (p.countries && typeof p.countries === 'string') ? p.countries : (Array.isArray(p.countries) ? p.countries.join(', ') : country);

      const linkHref = p.ref_url || p.wiki || p.wikipedia || p.url || '';
      const link = linkHref ? `<a href="${linkHref}" target="_blank" style="color: #1e40af;">Reference</a>` : '';

      const html = `
        <div style="max-width: 280px; padding: 8px;">
          <strong style="font-size: 14px;">${title}</strong><br>
          ${dateStr ? dateStr + '<br>' : ''}
          ${location ? location + '<br>' : ''}
          ${countriesList ? countriesList + '<br>' : ''}
          ${link}
        </div>
      `;
      new mapboxgl.Popup({ offset: 15 }).setLngLat(e.lngLat).setHTML(html).addTo(map);
    });

    initTimeline();
  });
</script>
</body>
</html>
